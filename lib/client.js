// Generated by CoffeeScript 1.6.3
var registerCollection, registerModel, wrapError;

registerModel = function(model, modelConnectionId, id) {
  var modelID, modelRef;
  if (id == null) {
    id = void 0;
  }
  modelID = id || model.cid;
  modelRef = model;
  if (!(ss.event.listeners("sync:" + modelConnectionId + ":" + modelID).length > 0)) {
    console.log("registering modelConnectionId", modelConnectionId);
    return ss.event.on("sync:" + modelConnectionId + ":" + modelID, function(msg) {
      return modelRef.trigger("backbone-sync-model", JSON.parse(msg));
    });
  }
};

registerCollection = function(collection, modelConnectionId) {
  var collectionRef;
  collectionRef = collection;
  console.log("registering collection", modelConnectionId);
  return ss.event.on("sync:" + modelConnectionId, function(msg) {
    return collectionRef.trigger("backbone-sync-collection", JSON.parse(msg));
  });
};

window.syncedModel = Backbone.Model.extend({
  sync: function(method, model, options) {
    var modelConnectionId, modelname, next, req;
    modelname = this.constructor.modelname;
    modelConnectionId = this.constructor.modelConnectionId || modelname;
    next = null;
    if (typeof options.next === "function") {
      next = options.next;
    }
    req = {
      modelname: modelname,
      modelConnectionId: modelConnectionId,
      method: method,
      model: model.toJSON(),
      params: options.params
    };
    if (model.isNew()) {
      req.cid = model.cid;
    }
    console.log("Model upsync", req);
    return ss.backbone(req, next);
  },
  initialize: function(attrs) {
    var deleted, model, modelConnectionId, modelname;
    if (attrs == null) {
      attrs = {};
    }
    modelname = this.constructor.modelname;
    modelConnectionId = this.constructor.modelConnectionId || modelname;
    if (!modelname) {
      throw "Cannot sync. You must set the name of the modelname on the Model class";
      delete this;
    }
    model = this;
    this.idAttribute = this.idAttribute || 'id';
    registerModel(model, modelConnectionId, attrs[this.idAttribute] || model.cid);
    deleted = false;
    return this.on("backbone-sync-model", function(res) {
      console.log("Model downsync", modelname, res);
      if (res.e) {
        return console.log(res.e);
      } else {
        if (res.method === "confirm") {
          registerModel(model, modelConnectionId, res.model[this.idAttribute]);
          this.set(res.model);
        }
        if (res.method === "update") {
          this.set(res.model);
        }
        if (res.method === "delete") {
          if (!deleted) {
            this.trigger("destroy");
          }
          if (this.collection) {
            this.collection.remove(this.idAttribute);
          }
          return deleted = true;
        }
      }
    });
  }
});

window.syncedCollection = Backbone.Collection.extend({
  sync: function(method, model, options) {
    var modelConnectionId, modelname, next, req;
    next = null;
    if (typeof options.next === "function") {
      next = options.next;
    }
    modelname = this.constructor.modelname;
    modelConnectionId = this.constructor.modelConnectionId || modelname;
    req = {
      modelname: modelname,
      modelConnectionId: modelConnectionId,
      method: method,
      model: model.toJSON(),
      params: options.params
    };
    console.log("Collection upsync", modelname, req, next);
    return ss.backbone(req, next);
  },
  fetchWhere: function(attributes, options) {
    var collection, model, success;
    attributes = attributes || {};
    options = (options ? _.clone(options) : {});
    if (options.parse === void 0) {
      options.parse = true;
    }
    success = options.success;
    collection = this;
    options.success = function(resp) {
      var method;
      method = (options.reset ? "reset" : "set");
      collection[method](resp, options);
      if (success) {
        success(collection, resp, options);
      }
      return collection.trigger("sync", collection, resp, options);
    };
    wrapError(this, options);
    model = new this.model(attributes);
    return this.sync("read", model, options);
  },
  initialize: function() {
    var collection, modelConnectionId, modelname;
    modelname = this.constructor.modelname;
    modelConnectionId = this.constructor.modelConnectionId || modelname;
    if (!modelname) {
      throw "Cannot sync. You must set the name of the modelname on the Collection class";
      return delete this;
    } else {
      collection = this;
      registerCollection(collection, modelConnectionId);
      return this.on("backbone-sync-collection", function(msg) {
        console.log("collection downsync", modelname, msg);
        if (msg.method === "create") {
          this.add(msg.model);
        }
        if (msg.method === "read") {
          this.add(msg.models, {
            parse: true,
            merge: true
          });
        }
        return this.trigger("change");
      });
    }
  }
});

wrapError = function(model, options) {
  var error;
  error = options.error;
  return options.error = function(resp) {
    if (error) {
      error(model, resp, options);
    }
    return model.trigger("error", model, resp, options);
  };
};
